# 前端面试之道

2 - JS基础知识点及常考面试题

3 - JS 基础知识点及常考面试题（二）

4- ES6 知识点及常考面试题

5 - JS 异步编程及常考面试题

6-手写 Promise

7-Event Loop

8-JS 进阶知识点及常考面试题

9-JS 思考题

10-DevTools Tips

11-浏览器基础知识点及常考面试题

12-浏览器缓存机制

13-浏览器渲染原理

14-安全防范知识点

15-从 V8 中看 JS 性能优化

16-性能优化琐碎事

17-Webpack 性能优化

18-实现小型打包工具

19-React 和 Vue 两大框架之间的相爱相杀

20-Vue 常考基础知识点

21-Vue 常考进阶知识点

22-React 常考基础知识点

23-React 常考进阶知识点

24-监控

25-UDP

26-TCP

27-HTTP 及 TLS

28-HTTP23

29-输入 URL 到页面渲染的整个流程

30-设计模式

31-常见数据结构

32-常考算法题解析

# 解锁前端面试体系核心攻略

02 闭包—从编译原理的角度理解作用域

03 闭包—探索词法作用域模型

04  闭包面试真题集中解析

05 闭包的应用

06 JS 内存管理机制解析

07 this 基本指向原则解析

08 改变 this 指向深入理解

09 JS 更进一步执行上下文与调用栈

10 原型编程范式与面向对象

11 原型与面向对象真题解析

12 异步编程模型与异步解决方案

13 全面掌握现代异步解决方案

14 Promise 命题思路全解析

15 起底 PromiseA+ —— 从实践到原理

16 起底 PromiseA+——决议程序（Resolution Procedure）

17 变量提升与暂时性死区

18 ES2015+考点集中解析

19 DOM 基本功

20 DOM 事件体系（一）

21 DOM事件体系（二）

22 真题手把手事件的防抖与节流

23 导读-开始之前

24 概览与预备知识——让”黑盒“不再神秘

25 图解浏览器渲染引擎工作原理

26 命题难点深入挖掘—重绘与重排

27  浏览器中的 EventLoop

28灵魂拷问：Node中的EventLoop与浏览器有何不同？

29 Node事件循环命题思路剖析

30 React基本功（一）——图解新旧生命周期

31 React基本功（二）——深入组件通信机制

32 React基本功（三）——命题思路点拨

33 真正理解虚拟DOM（一）——虚拟DOM思想

34 真正理解虚拟DOM（二）——Diff算法 &amp; 面试考点解析

35 React16题眼理解Fiber思想

36 Vue核心——响应式原理源码级解析

37 Vue核心——nextTick原理源码级解析

38 Vue 优质真题深度解读

39 TCP 与 UDP

40 从 HTTP 到 HTTP2.0

41 真正理解 HTTPS

42 跨域解决方案

43 重点布局方案（上）

44 重点布局方案（下）

45 响应式布局原理与实践（上）

46 响应式布局原理与实践（下）

47 设计模式知识脉络梳理+好题精做慕课专栏

48 前端算法知识脉络梳理+好题精做慕课专栏



# Web 前端面试指南与高频考题解析

一面 1：ES 基础知识点与高频考题解析

一面 2：JS-Web-API 知识点与高频考题解析

一面 3：CSS-HTML 知识点与高频考题解析

一面 4：从容应对算法题目

一面 5：浏览器相关知识点与高频考题解析

一面 6：开发环境相关知识点与高频考题解析

二面 1：如何回答常见的软技能问题

二面 2：如何介绍项目及应对项目细节追问





# 前端核心知识进阶

001--一网打尽this，对执行上下文说Yes

002--老司机也会在闭包相关知识点翻车（上）

003--老司机也会在闭包相关知识点翻车（下）

004--我们不背诵API，只实现API

005--JavaScript知识图谱和高频考点梳理

006--其他基础题库

007--异步不可怕“死记硬背”+实践拿下（上）

008--异步不可怕“死记硬背”+实践拿下（下）

009--你以为我真的想让你手写Promise吗（上）

010--你以为我真的想让你手写Promise吗（下）

011--面向对象和原型——永不过时的话题

012--究竟该如何学习与时俱进的ES

013--前端面试离不开的“面子工程”

014--进击的CSS和HTML

015--响应式布局和Bootstrap的实现分析

016--触类旁通多种框架

017--你真的懂React吗

018--揭秘React真谛组件设计

019--揭秘React真谛数据状态管理

020--React的现状与未来

021--同构应用中你所忽略的细节

022--从框架和类库，我们该学到什么

023--深入浅出模块化（含treeshaking）（上）

024--深入浅出模块化（含treeshaking）（下）

025--webpack工程师和前端工程师（上）

026--webpack工程师和前端工程师（下）

027--前端工程化背后的项目组织设计（上）

028--前端工程化背后的项目组织设计（下）

029--代码规范工具及背后技术设计（上）

030--代码规范工具及背后技术设计（下）

031--性能监控和错误收集与上报（上）

032--性能监控和错误收集与上报（下）

033--性能优化问题，老司机如何解决（上）

034--性能优化问题，老司机如何解决（下）

035--以React为例，说说框架和性能（上）

036--以React为例，说说框架和性能（下）

037--揭秘前端设计模式（上）

038--揭秘前端设计模式（下）

039--剖析无处不在的数据结构

040--古老又新潮的函数式

041--那些年常考的前端算法（上）

041--那些年常考的前端算法（中）

041--那些年常考的前端算法（下）

044--分析一道“微信”面试题

045--离不开的网络基础

046--缓存谁都懂，一问都哑巴（上）

047--缓存谁都懂，一问都哑巴（下）

048--HTTP的深思我从何而来，去向何处

049--不可忽视的前端安全-单页应用鉴权设计







# CSS面试题

## HTML 语义化

​	比较可读，易读，对人比较友好，虽然全部用div也可以，但是明显没有h1，p，ul，li这种清晰，假设不是给人看，给搜索引擎看，比如爬虫看到下面1的代码根本看不出来啥，但是看2就很容易分清网页的主次关系，也很容易通过正确的搜索结果返回给用户，`h1`标签就代表是标题；`p`里面的就是段落详细内容，权重肯定没有标题高，`strong`就是加粗的强调的内容，全部都用`<div>`标签，那搜索引擎将很难理解我们网页的内容

​	为了加强 HTML 语义化，HTML5 标准中又增加了`header` `section` `article`等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。

```jsx
// 1
<div>
  <div></div>
</div>

// 2
<div>
  <h1></h1>
  <p></p>
</div>
```

## 布局

### 盒模型宽度计算

```js
// offsetWidth = 内容宽度 + 内边距 + 边框，无外边距
// box-sizing: border-box (width = 内容宽度 + 内边距 + 边框，无外边距)
document.getElementById('div').offsetWidth
```

### margin纵向重叠

- 相邻元素的margin-top和margin-bottom会发生重叠，取大的
- 空的内容也会重叠，被忽略掉

### margin 负值

- maigin-top和left，该元素会向上，向左移动
- margin-bottom 和 right，自身不受影响下方元素和右侧元素分别上移，左移

### BFC的理解和应用

​	Block format context，块级格式化上下文

​	它是一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素

​	形成BFC的常见情况如下：

- float 不是 none
- position 是absolute或fixed
- overflow 不是visible
- display 是 flex，inline-block等

​    常见应用是清除浮动

```html
<style>
  .left {
    float: left;
  }
</style>
<div class="container">
	<img src="xxx" class="left" />
  <p>文字</p>
</div>
```

​	如上所示，img设置浮动以后直接脱离文档流，所导致的情况就是没有撑开container，且p还是独占一行

```jsx
<style>
  .left {
    float: left;
  }
  .bfc { 
    overflow: hidden // 触发元素BFC
  }
</style>
<div class="container bfc">
	<img src="xxx" class="left" />
  <p class="bfc">文字</p>
</div>
```

​	如上，container完全被撑开了，包裹住了图片和文字，并且文字没有独占一行的同时还在img的右侧，一起占了一行

### float 布局

​	圣杯和双飞翼是三栏布局，中间一栏最先加载和渲染（内容最重要）

​	两侧内容固定，中间随着宽度自适应

​	技术要点：

1. float 布局，两侧使用margin 负值，以便和中间内容横向重叠，
2. 防止中间内容被两侧覆盖，一个用padding（圣杯），一个用margin（双飞翼）

#### 圣杯布局

```jsx
<div id="header"></div>
<div id="container">
  <div id="center" class="column"></div>
  <div id="left" class="column"></div>
  <div id="right" class="column"></div>
</div>
<div id="footer"></div>
```

```less
#container {
  padding-left: 200px;
  padding-right: 200px;
}
.column {
  float: left;
}
#center {
  width: 100%;
}
#left {
  width: 200px;
  margin-left: -100%;
  right: 200px;
  position: relatove;
}
#right {
  width: 150px;
  margin-right: -150px;
  // margin-right负值可以理解为自身的宽度在外界来看缩小了150px，配合前面margin负值理解
  // 设置为自己的宽度值后，这样就在外界看来没有宽度了
}
#footer {
  clear: both; // 去浮动
}
```



#### 双飞翼布局

```jsx
<div id="main" class="col">
	<div id="main-wrap">
  </div>
</div>
<div id="left" class="col"></div>
<div id="right" class="col"></div>
```

```less
.col {
  float: left; 
}
#main {
  width: 100%;
  height: 200px;
}
#main-wrap {
  margin: 0 200px 0 150px;
}
#left {
  width: 200px;
  height: 200px;
  margin-left: -100%;
}
#right {
  width: 200px;
  height: 200px;
  margin-left: -190px;
}
```



#### 手写clearfix

​	所有 float 元素的父容器，一般情况下都应该加`clearfix`这个 class。

```less
.clearfix:after {
  content: '';
  display: table;
  clear: both;
}
.clearfix {
  *zoom: 1; /* 兼容 IE 低版本 */
}
```

### flex 布局

- flex-direction - 主轴的方向
- justify-content - 主轴对其方式
- align-items - 和主轴垂直的方向对其方式
- flex-wrap - 是不是换行
- align-self - 子元素在交叉轴的对其方式

flex实现一个三点的骰子

```jsx
<div id="box">
  <span class="item"></span>
  <span class="item"></span>
  <span class="item"></span>
</div>
```

```less
#box {
  display: flex;
  justify-content: space-between;
}
.item:nth-child(2) {
  align-self: center;
}
.item:nth-child(3) {
  align-self: flex-end;
}
```



## 定位

​	absolute是依据最近的已定位的父元素定位，找不到的话就是body

### 水平居中

- inline 元素：`text-align: center;`
- block 元素：`margin: auto;`
- 绝对定位元素：可结合`left`和`margin`实现，但是必须知道宽度。

```less
.container {
    position: relative;
    width: 500px;
}
.item {
    width: 300px;
    height: 100px;
    position: absolute;
    left: 50%; // 1
    margin-left: -150px; // 2
}
```

### 垂直居中

- inline 元素：可设置`line-height`的值等于`height`值，如单行文字垂直居中
- 绝对定位元素

```js
// 1. 可结合`left`和`margin`实现，兼容性好
// 缺点：必须知道尺寸。
.container {
    position: relative;
    height: 200px;
}
.item {
    width: 80px;
    height: 40px;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-top: -20px;
    margin-left: -40px;
}
```

```less
// 2. 结合`transform`实现居中，不需要提前知道尺寸
// 缺点：兼容性不好
.container {
    position: relative;
    height: 200px;
}
.item {
    width: 80px;
    height: 40px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}
```

```less
// 3. 结合`margin: auto`，不需要提前知道尺寸，兼容性好。
.container {
    position: relative;
    height: 300px;
}
.item {
    width: 100px;
    height: 50px;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
```



## 图文样式

### line-height如何继承

- 写具体数值，如30px，则继承该值
- 写比例，如 2 / 1.5，则继承该比例
- 写百分比，如200%，则继承计算出来的值

```less
body {
  font-size: 20px;
  line-height: 30px; // 1
  line-height: 1.5; // 2
  line-height: 200%; // 3
}
p {
  font-size: 16px;
  // 1 -> line-height: 30px;
  // 2 -> line-height: 16 * 1.5 = 24px;
  // 3 -> line-height: 20 * 200% = 40px;
}
```



## 响应式

### rem

​	是一个长度单位，相对于跟元素，r 是 root 的意思

```less
html {
  font-size: 100px;// 1rem = 100px
}
div {
  width: 0.16rem;
}
```

- media-query（CSS3），可以根据不同屏幕的宽度设置根元素 font-size

```js
@media only screen and (max-width: 374px) {
  // 表示iphone5(320px)或更小, 因为iphone6/7/8...最小是375px
  html {
    font-size: 86px;
  }
}
@media only screen and (min-width: 375px) and (max-width: 413px){
  // iphone6/7/8
  html {
    font-size: 100px;
  }
}
// 375/320 === 100/86 就这么得来的
```

​	em 也是相对长度单位，不过相对于父元素，不常用



### vw/vh

​	rem的弊端，具有阶梯性

```js
window.screen.height // 屏幕高度
window.innerHeight // 网页视口高度，减掉地址栏啥啥的，=== 100vh
document.body.clientHeight // body高度

vw 和 vh 是网页视口宽度高度的百分之1
vmax 和 vmin -> 哪个大以哪个为准，比如vh大于vw，则1vmax = 1vh
```



# JS基础 - 变量类型和计算

## 原始类型

## 对象类型

## typeof & instanceof

​	instanceof内部机制是通过原型链判断的

​	此外还有个方法：Object.prototype.toString

```js
function getType(obj){
  let type  = typeof obj;
  if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // 注意正则中间有个空格
}
```

## 深浅拷贝

**浅拷贝**

1. Object.assign

```js
let b = Object.assign({}, a)
```

2. `...`

```js
let b = { ...a }
```

​	上两种有什么问题：-> 2

3. concat 和 slice 处理数组

```js
let newArr = arr.concat();
let newArr = arr.slice();
```



**深拷贝**

1. `JSON.parse(JSON.stringify(object))`

   - 拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；

   - 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。

   - 拷贝 Date 引用类型会变成字符串；

   - 无法拷贝不可枚举的属性；

   - 无法拷贝对象的原型链；

   - 拷贝 RegExp 引用类型会变成空对象；

   - 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；

   

2. `_.cloneDeep`

## 手写浅拷贝

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```



## 手写深拷贝

```js
function deepClone(obj) {
  function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') && o !== null
  }

  if (!isObject(obj)) {
    throw new Error('非对象')
  }

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : { ...obj }
  Reflect.ownKeys(newObj).forEach(key => {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })

  return newObj
}
```

## 手写 instanceof

```js
function myInstanceof(left, right) {
  if(typeof left !== 'object' || left === null) return false;
  let proto = Object.getPrototypeOf(left);
  while(true) {
    if(proto === null) return false;
    if(proto === right.prototype) return true
    proto = Object.getPrototypeof(proto);
  }
}
```



## var let 和 const

- 变量提升
- `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上
- 块级作用域
- `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值

# JS基础 - 继承

## 组合继承

```js
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()
```

​	子类的原型上多了不需要的父类属性，存在内存上的浪费，而且调用了两次父类构造函数

## 寄生组合继承

```js
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
```



## class 继承

```js
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
```



# JS基础 - 原型和原型链

​	打印obj，你发现`obj.__proto__.constructor.prototype === obj.__proto__`

​	得出结论，构造函数的原型（`prototype`）又指向实例对象的原型（`__proto__`）

​	所有从原型或更高级原型中得到、执行的方法，其中的`this`在执行时，就指向了当前这个触发事件执行的对象。因此`printName`和`alertName`中的`this`都是`f`。

# JS基础 - 作用域和闭包

​	闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

​	题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就`alert`弹出其编号

```html
<ul>
    <li>编号1，点击我请弹出1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
</ul>
```

```js
var list = document.getElementsByTagName('li');
for (var i = 0; i < list.length; i++) {
    list[i].addEventListener('click', function(i){
        return function(){
            alert(i + 1)
        }
    }(i), true)
}
```



# JS基础 - 其他

## map, filter, reduce

​	map 是对每个数组做操作返回

​	filter 是只返回为true的

​	reduce 可以将数组中的元素通过回调函数最终转换为一个值，接受两个参数，分别是回调函数和初始值

```js
const sum = arr.reduce((acc, current) => acc + current, 0)
```

## 手写 call apply bind

```js
Function.prototype.myCall = function(context, ...args) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const result = context.fn(...args)
  delete context.fn
  return result
}
```

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```

​	1

## 手写 new

在调用 `new` 的过程中会发生以上四件事情：

1. 创建一个新对象；

2. 将构造函数的作用域赋给新对象（this 指向新对象）；

3. 执行构造函数中的代码（为这个新对象添加属性）；

4. 返回新对象。

```js
function create() {
  let obj = {}
  let Con = [].shift.call(arguments)
  obj.__proto__ = Con.prototype
  let result = Con.apply(obj, arguments)
  return result instanceof Object ? result : obj
}
```

​	

# JS基础 - 异步

## Generator

​	通过 * 来声明generator函数，执行它普通函数不同，会返回一个迭代器，要执行迭代器的next才会继续往下执行，第一次执行时，会暂停在第一个yield处，并向外返回一个值。如果传参数的话，会代替上一个yield的返回值

## 常用定时器

注意点

- 因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行
- 如果定时器 `setInterval` 执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行

# JS 异步进阶

​	大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，当遇到异步的代码时，会被**挂起**并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。

​	不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 **微任务**（microtask） 和 **宏任务**

​	微任务包括 `process.nextTick` ，`promise` ，`MutationObserver`。

​	宏任务包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`。

# JS-Web-API-DOM

# JS-Web-API-BOM 

# JS-Web-API-事件

## 事件触发三阶段

事件触发有三个阶段：

- `window` 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 `window` 传播，遇到注册的冒泡事件会触发

# JS-Web-API-Ajax

# JS-Web-API-存储

# http 面试题

# 开发环境

# 运行环境















