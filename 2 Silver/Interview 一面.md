# 前端面试之道

2 - JS基础知识点及常考面试题

3 - JS 基础知识点及常考面试题（二）

4- ES6 知识点及常考面试题

5 - JS 异步编程及常考面试题

6-手写 Promise

7-Event Loop

8-JS 进阶知识点及常考面试题

9-JS 思考题

10-DevTools Tips

11-浏览器基础知识点及常考面试题

12-浏览器缓存机制

13-浏览器渲染原理

14-安全防范知识点

15-从 V8 中看 JS 性能优化

16-性能优化琐碎事

17-Webpack 性能优化

18-实现小型打包工具

19-React 和 Vue 两大框架之间的相爱相杀

20-Vue 常考基础知识点

21-Vue 常考进阶知识点

22-React 常考基础知识点

23-React 常考进阶知识点

24-监控

25-UDP

26-TCP

27-HTTP 及 TLS

28-HTTP23

29-输入 URL 到页面渲染的整个流程

30-设计模式

31-常见数据结构

32-常考算法题解析

# 解锁前端面试体系核心攻略

02 闭包—从编译原理的角度理解作用域

03 闭包—探索词法作用域模型

04  闭包面试真题集中解析

05 闭包的应用

06 JS 内存管理机制解析

07 this 基本指向原则解析

08 改变 this 指向深入理解

09 JS 更进一步执行上下文与调用栈

10 原型编程范式与面向对象

11 原型与面向对象真题解析

12 异步编程模型与异步解决方案

13 全面掌握现代异步解决方案

14 Promise 命题思路全解析

15 起底 PromiseA+ —— 从实践到原理

16 起底 PromiseA+——决议程序（Resolution Procedure）

17 变量提升与暂时性死区

18 ES2015+考点集中解析

19 DOM 基本功

20 DOM 事件体系（一）

21 DOM事件体系（二）

22 真题手把手事件的防抖与节流

23 导读-开始之前

24 概览与预备知识——让”黑盒“不再神秘

25 图解浏览器渲染引擎工作原理

26 命题难点深入挖掘—重绘与重排

27  浏览器中的 EventLoop

28灵魂拷问：Node中的EventLoop与浏览器有何不同？

29 Node事件循环命题思路剖析

30 React基本功（一）——图解新旧生命周期

31 React基本功（二）——深入组件通信机制

32 React基本功（三）——命题思路点拨

33 真正理解虚拟DOM（一）——虚拟DOM思想

34 真正理解虚拟DOM（二）——Diff算法 &amp; 面试考点解析

35 React16题眼理解Fiber思想

36 Vue核心——响应式原理源码级解析

37 Vue核心——nextTick原理源码级解析

38 Vue 优质真题深度解读

39 TCP 与 UDP

40 从 HTTP 到 HTTP2.0

41 真正理解 HTTPS

42 跨域解决方案

43 重点布局方案（上）

44 重点布局方案（下）

45 响应式布局原理与实践（上）

46 响应式布局原理与实践（下）

47 设计模式知识脉络梳理+好题精做慕课专栏

48 前端算法知识脉络梳理+好题精做慕课专栏



# Web 前端面试指南与高频考题解析

一面 1：ES 基础知识点与高频考题解析

一面 2：JS-Web-API 知识点与高频考题解析

一面 3：CSS-HTML 知识点与高频考题解析

一面 4：从容应对算法题目

一面 5：浏览器相关知识点与高频考题解析

一面 6：开发环境相关知识点与高频考题解析

二面 1：如何回答常见的软技能问题

二面 2：如何介绍项目及应对项目细节追问





# 前端核心知识进阶

001--一网打尽this，对执行上下文说Yes

002--老司机也会在闭包相关知识点翻车（上）

003--老司机也会在闭包相关知识点翻车（下）

004--我们不背诵API，只实现API

005--JavaScript知识图谱和高频考点梳理

006--其他基础题库

007--异步不可怕“死记硬背”+实践拿下（上）

008--异步不可怕“死记硬背”+实践拿下（下）

009--你以为我真的想让你手写Promise吗（上）

010--你以为我真的想让你手写Promise吗（下）

011--面向对象和原型——永不过时的话题

012--究竟该如何学习与时俱进的ES

013--前端面试离不开的“面子工程”

014--进击的CSS和HTML

015--响应式布局和Bootstrap的实现分析

016--触类旁通多种框架

017--你真的懂React吗

018--揭秘React真谛组件设计

019--揭秘React真谛数据状态管理

020--React的现状与未来

021--同构应用中你所忽略的细节

022--从框架和类库，我们该学到什么

023--深入浅出模块化（含treeshaking）（上）

024--深入浅出模块化（含treeshaking）（下）

025--webpack工程师和前端工程师（上）

026--webpack工程师和前端工程师（下）

027--前端工程化背后的项目组织设计（上）

028--前端工程化背后的项目组织设计（下）

029--代码规范工具及背后技术设计（上）

030--代码规范工具及背后技术设计（下）

031--性能监控和错误收集与上报（上）

032--性能监控和错误收集与上报（下）

033--性能优化问题，老司机如何解决（上）

034--性能优化问题，老司机如何解决（下）

035--以React为例，说说框架和性能（上）

036--以React为例，说说框架和性能（下）

037--揭秘前端设计模式（上）

038--揭秘前端设计模式（下）

039--剖析无处不在的数据结构

040--古老又新潮的函数式

041--那些年常考的前端算法（上）

041--那些年常考的前端算法（中）

041--那些年常考的前端算法（下）

044--分析一道“微信”面试题

045--离不开的网络基础

046--缓存谁都懂，一问都哑巴（上）

047--缓存谁都懂，一问都哑巴（下）

048--HTTP的深思我从何而来，去向何处

049--不可忽视的前端安全-单页应用鉴权设计







# CSS面试题

# JS基础 - 变量类型和计算

## 原始类型

## 对象类型

## typeof & instanceof

​	instanceof内部机制是通过原型链判断的

​	此外还有个方法：Object.prototype.toString

```js
function getType(obj){
  let type  = typeof obj;
  if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // 注意正则中间有个空格
}
```

## 深浅拷贝

**浅拷贝**

1. Object.assign

```js
let b = Object.assign({}, a)
```

2. `...`

```js
let b = { ...a }
```

​	上两种有什么问题：-> 2

3. concat 和 slice 处理数组

```js
let newArr = arr.concat();
let newArr = arr.slice();
```



**深拷贝**

1. `JSON.parse(JSON.stringify(object))`

   - 拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；

   - 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。

   - 拷贝 Date 引用类型会变成字符串；

   - 无法拷贝不可枚举的属性；

   - 无法拷贝对象的原型链；

   - 拷贝 RegExp 引用类型会变成空对象；

   - 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；

   

2. `_.cloneDeep`

## 手写浅拷贝

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```



## 手写深拷贝

```js
function deepClone(obj) {
  function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') && o !== null
  }

  if (!isObject(obj)) {
    throw new Error('非对象')
  }

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : { ...obj }
  Reflect.ownKeys(newObj).forEach(key => {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })

  return newObj
}
```

## 手写 instanceof

```js
function myInstanceof(left, right) {
  if(typeof left !== 'object' || left === null) return false;
  let proto = Object.getPrototypeOf(left);
  while(true) {
    if(proto === null) return false;
    if(proto === right.prototype) return true
    proto = Object.getPrototypeof(proto);
  }
}
```



## var let 和 const

- 变量提升
- `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上
- 块级作用域
- `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值

# JS基础 - 继承

## 组合继承

```js
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()
```

​	子类的原型上多了不需要的父类属性，存在内存上的浪费，而且调用了两次父类构造函数

## 寄生组合继承

```js
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
```



## class 继承

```js
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
```



# JS基础 - 原型和原型链

​	当我们创建一个对象时 `let obj = { age: 25 }`，我们可以发现能使用很多种函数，但是我们明明没有定义过它们

​	打印obj，你发现`obj.__proto__.constructor.prototype === obj.__proto__`

​	得出结论，构造函数的原型（`prototype`）又指向实例对象的原型（`__proto__`）

# JS基础 - 作用域和闭包

​	闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

# JS基础 - 其他

## map, filter, reduce

​	map 是对每个数组做操作返回

​	filter 是只返回为true的

​	reduce 可以将数组中的元素通过回调函数最终转换为一个值，接受两个参数，分别是回调函数和初始值

```js
const sum = arr.reduce((acc, current) => acc + current, 0)
```

## 手写 call apply bind

```js
Function.prototype.myCall = function(context, ...args) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const result = context.fn(...args)
  delete context.fn
  return result
}
```

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```

​	1

## 手写 new

在调用 `new` 的过程中会发生以上四件事情：

1. 创建一个新对象；

2. 将构造函数的作用域赋给新对象（this 指向新对象）；

3. 执行构造函数中的代码（为这个新对象添加属性）；

4. 返回新对象。

```js
function create() {
  let obj = {}
  let Con = [].shift.call(arguments)
  obj.__proto__ = Con.prototype
  let result = Con.apply(obj, arguments)
  return result instanceof Object ? result : obj
}
```

​	

# JS基础 - 异步

## Generator

​	通过 * 来声明generator函数，执行它普通函数不同，会返回一个迭代器，要执行迭代器的next才会继续往下执行，第一次执行时，会暂停在第一个yield处，并向外返回一个值。如果传参数的话，会代替上一个yield的返回值

## 常用定时器

注意点

- 因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行
- 如果定时器 `setInterval` 执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行

# JS 异步进阶

​	大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，当遇到异步的代码时，会被**挂起**并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。

​	不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 **微任务**（microtask） 和 **宏任务**

​	微任务包括 `process.nextTick` ，`promise` ，`MutationObserver`。

​	宏任务包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`。

# JS-Web-API-DOM

# JS-Web-API-BOM 

# JS-Web-API-事件

## 事件触发三阶段

事件触发有三个阶段：

- `window` 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 `window` 传播，遇到注册的冒泡事件会触发

# JS-Web-API-Ajax

# JS-Web-API-存储

# http 面试题

# 开发环境

# 运行环境















